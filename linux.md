# sudo env var

```bash
export MY_HOST=127.0.0.1
sudo ./Launch.sh
```
Launch.sh에서 MY_HOST 환경변수를 사용한다고 가정합니다.
하지만 Launch.sh를 sudo로 실행하면 MY_HOST 환경변수를 찾을 수 없습니다.

이 때 3가지의 해결 방법이 있습니다.

1. 전체 환경 변수 전달

```bash 
sudo --preserve-env ./Launch.sh
```

`-E` 또는 `--preserve-env`를 사용하면 sudo에서 모든 환경변수를 사용할 수있습니다.  


2. 필요한 환경변수만 전달

```bash
sudo --preserve-env=MY_HOST ./Launch.sh 
```

전체 환경변수를 전달하는 것보다 필요한 환경변수만 전달하는게 더 안전합니다.  
원하는 환경변수 이름으로 전달할 수 있습니다.  


3. 환경변수 즉석으로 직접 만들기

```bash
sudo MY_HOST=127.0.0.1 ./Launch.sh 
```

환경변수를 command에서 직접 만들 수 있습니다.







---
---
---

# sed
S&P 500 가격 데이터를 investing.com에서 구해왔습니다. 이 데이터를 선언적으로 편집해 바로 볼 수 있는 유용한 도구가 있습니다.
바로 sed 

가격 데이터인 HistoricalData.csv에 S&P 500 가격 데이터가 있을 때 아래 명령어를 쳐보자 첫 행이 나옵니다.

```
sed -n '1p' HistoricalData.csv
-> "Date","Price","Open","High","Low","Vol.","Change %"
```

이번에는 여러줄을 출력해보겠습니다.
```
sed -n '3,5p' HistoricalData.csv
->
"02/02/2023","4,179.76","4,158.68","4,195.44","4,141.88","","1.47%"
"02/01/2023","4,119.21","4,070.07","4,148.95","4,037.20","","1.05%"
"01/31/2023","4,076.60","4,020.85","4,077.16","4,020.44","","1.46%"
```

-n은 작업된 부분만 출력하게 해줍니다. 궁금하면 빼보고 명령을 실행해보세요.

'3,5p' 이 명령어를 쓰면 컬럼 명이 보이지 않습니다. 이 때 -e를 사용할 수 있습니다.

sed -n -e '1p' -e '3,5p' HistoricalData.csv
-> "Date","Price","Open","High","Low","Vol.","Change %"
"02/02/2023","4,179.76","4,158.68","4,195.44","4,141.88","","1.47%"
"02/01/2023","4,119.21","4,070.07","4,148.95","4,037.20","","1.05%"
"01/31/2023","4,076.60","4,020.85","4,077.16","4,020.44","","1.46%"


매달 첫 가격 정보를 가져오려면 어떻게 해야할까요?
```
sed -n -e '1p' -e '/"[0-9]*/01/p' HistoricalData.csv


"Date","Price","Open","High","Low","Vol.","Change %"
"02/01/2023","4,119.21","4,070.07","4,148.95","4,037.20","","1.05%"
"12/01/2022","4,076.57","4,087.14","4,100.51","4,050.87","","-0.09%"
"11/01/2022","3,856.10","3,901.79","3,911.79","3,843.80","","-0.41%"
"09/01/2022","3,966.85","3,936.73","3,970.23","3,903.65","","0.30%"
```

어렇게 만들 수 있습니다. 하지만 10월의 1일 데이터가 없어 첫 데이터가 없습니다. 보완하기 위해서는 다른 방법을 사용해야 합니다.








---
---
---

# tunneling

터널링이 유용한 상황입니다.
- 접속하고 싶은 최종 목적지는 외부에 공개되지 않습니다.
- 하지만 중간 목적지는 외부와 개방되어 있습니다. 그리고 최종 목적지에도 갈 수 있습니다.

즉, 아래 구조를 이용하면 local에서 최종 목적지까지 접근할 수 있습니다.  
```
local → 중간 목적지(흔히 bastion이라 함) → 최종 목적지
```

하지만 bastion에서 ssh를 이용해 최종 목적지까지 접속하려면 bastion에 최종 목적지의 key file이 존재해야 합니다.  

외부에 노출되어 있는 bastion이 최종 목적지의 key를 가지고 있는 것은 위험합니다.

이 때 터널링을 이용해 local에서 최종 목적지까지 터널을 뚫을 수 있습니다.

아래 명령어를 보세요.

```
// 터널을 뚫어줍니다.
ssh -i {중간 목적지의 key} -L {localhost:2222}:{최종 목적지 ip:5554} ubuntu@{bastion ip}

// localhost의 세션을 하나 더 연 후 localhost에서 최종 목적지까지 한번에 접속합니다.
ssh -i {최종 목적지의 key} {localhost:2222}
```


터널을 뚫는 명령어를 조금 더 부연설명 하겠습니다.

- `-L {localhost:2222}:{최종 목적지 ip:5554}`은 최종 목적지의 ip를 localhost의 2222에 할당하겠다는 뜻입니다.
- {최종 목적지 ip:5554}를 {localhost:2222}에 다리를 놓는데 ubuntu@{bastion ip}을 이용하겠다는 뜻입니다.




